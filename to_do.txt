CREATE TABLE exp_logs (
    log_id          INT AUTO_INCREMENT PRIMARY KEY COMMENT '로그 고유 ID',
    user_id         INT NOT NULL COMMENT '학생 ID',
    amount          INT NOT NULL COMMENT '획득 경험치 양',
    total_exp_after INT NOT NULL COMMENT '획득 후 누적 경험치 (스냅샷)',
    level_after     INT NOT NULL COMMENT '획득 후 당시 레벨 (스냅샷)',
    change_type     ENUM('QUEST', 'ATTENDANCE', 'ADMIN_MANUAL', 'EVENT') COMMENT '획득 경로',
    reference_id    INT COMMENT '관련 ID (예: 퀘스트 로그 ID)',
    description     VARCHAR(100) COMMENT '상세 내용',
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '발생 시간'
);

CREATE TABLE point_logs (
    log_id          INT AUTO_INCREMENT PRIMARY KEY COMMENT '로그 고유 ID',
    user_id         INT NOT NULL COMMENT '학생 ID',
    amount          INT NOT NULL COMMENT '변동량 (양수: 획득, 음수: 사용)',
    balance_after   INT NOT NULL COMMENT '변동 후 잔액 (스냅샷)',
    change_type     ENUM('QUEST', 'ATTENDANCE', 'SHOP', 'ADMIN_MANUAL', 'EVENT') COMMENT '변동 사유 유형',
    reference_id    INT COMMENT '관련 ID (예: 퀘스트 로그 ID, 구매 ID)',
    description     VARCHAR(100) COMMENT '상세 내용 (예: 성경읽기 보상)',
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '발생 시간'
);

CREATE TABLE quest_logs (
    log_id          INT AUTO_INCREMENT PRIMARY KEY COMMENT '로그 고유 ID',
    user_id         INT NOT NULL COMMENT '학생 ID (users 테이블 FK)',
    quest_id        INT NOT NULL COMMENT '퀘스트 ID (quests 테이블 FK)',
    status          ENUM('PENDING', 'APPROVED', 'REJECTED') DEFAULT 'PENDING' COMMENT '상태(대기, 승인, 반려)',
    proof_text      TEXT COMMENT '학생이 남긴 인증 글',
    proof_image_url VARCHAR(255) COMMENT '인증샷 이미지 경로',
    admin_comment   VARCHAR(255) COMMENT '선생님 피드백(반려 사유 등)',
    processed_by    INT COMMENT '처리한 선생님 ID',
    processed_at    DATETIME COMMENT '승인/반려 처리 시간',
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '요청 시간',
    
    INDEX idx_user_status (user_id, status) -- 학생별, 상태별 조회 속도 향상
);

CREATE TABLE quests (
    quest_id        INT AUTO_INCREMENT PRIMARY KEY COMMENT '퀘스트 고유 ID',
    title           VARCHAR(100) NOT NULL COMMENT '퀘스트 제목',
    description     TEXT COMMENT '퀘스트 상세 설명',
    reward_exp      INT DEFAULT 0 COMMENT '완료 시 지급 경험치',
    reward_point    INT DEFAULT 0 COMMENT '완료 시 지급 포인트(골드)',
    quest_type      ENUM('DAILY', 'WEEKLY', 'EVENT', 'ONE_TIME') DEFAULT 'DAILY' COMMENT '유형(일일, 주간, 이벤트, 1회성)',
    target_grade    VARCHAR(20) DEFAULT 'ALL' COMMENT '대상 학년(전체, 1학년 등)',
    is_active       BOOLEAN DEFAULT TRUE COMMENT '활성화 여부(TRUE: 노출, FALSE: 숨김)',
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '생성일',
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일'
);

quests: 퀘스트의 정의 (제목, 설명, 보상 등)

quest_logs: 학생들이 퀘스트를 수행한 기록 (승인 대기/완료 상태 포함)

point_logs: 포인트(Gold/달란트) 획득 및 사용 내역 (장부)

exp_logs: 경험치(XP) 획득 및 차감 내역 (성장 기록)


CREATE TABLE level_rules (
    level           INT PRIMARY KEY COMMENT '레벨 (1, 2, 3...)',
    required_exp    INT NOT NULL COMMENT '해당 레벨 도달에 필요한 최소 누적 경험치',
    rank_name       VARCHAR(50) COMMENT '해당 레벨의 호칭 (예: 견습 용사, 말씀의 기사)',
    reward_item_id  INT DEFAULT NULL COMMENT '레벨업 시 지급할 보상 아이템 ID (옵션)',
    
    -- 인덱스: 경험치로 레벨을 빨리 찾기 위함
    INDEX idx_required_exp (required_exp)
);
level	required_exp	rank_name	설명
1	0	🐣 새싹 용사	가입 즉시 시작
2	100	🌱 떡잎 용사	퀘스트 2~3개 완료 시
3	300	⚔️ 견습 용사	초반 성취감 구간
4	600	🛡️ 정예 용사	난이도 상승
5	1,000	👑 믿음의 용사	고레벨 구간

2. 사용자 테이블 수정 (users)
사용자 테이블에는 현재 누적 경험치와 현재 레벨을 저장해두어야 매번 계산하지 않아 부하를 줄일 수 있습니다.

SQL

ALTER TABLE users ADD COLUMN total_exp INT DEFAULT 0 COMMENT '누적 경험치';
ALTER TABLE users ADD COLUMN level INT DEFAULT 1 COMMENT '현재 레벨';
3. 핵심 로직: 레벨 산정 및 레벨업 처리
학생이 퀘스트를 완료하여 경험치를 획득했을 때, 시스템이 어떻게 레벨을 계산해야 하는지 보여주는 SQL 로직입니다.

시나리오: 학생이 50 EXP를 획득했을 때
1단계: 경험치 지급 (UPDATE)

SQL

UPDATE users 
SET total_exp = total_exp + 50 
WHERE user_id = 1;
2단계: 레벨 재산정 (SELECT) 변경된 total_exp를 기준으로, level_rules 테이블에서 달성 가능한 최대 레벨을 조회합니다.

SQL

-- 내 경험치(total_exp)보다 작거나 같은 required_exp 중 가장 높은 레벨을 찾음
SELECT MAX(level) as calculated_level
FROM level_rules
WHERE required_exp <= (SELECT total_exp FROM users WHERE user_id = 1);
3단계: 레벨업 여부 확인 및 적용

calculated_level이 현재 users.level보다 높다면? -> 레벨업 발생! 🎉

이때 users.level을 업데이트하고, 레벨업 축하 알림을 띄워줍니다.

4. (보너스) '다음 레벨까지 남은 경험치' 계산법
프론트엔드(UI)에서 **경험치 바(Progress Bar)**를 그리기 위해 필요한 데이터를 뽑는 쿼리입니다.

SQL

SELECT 
    u.level AS current_level,
    u.total_exp,
    next_lvl.required_exp AS next_level_exp,
    -- 다음 레벨까지 남은 경험치
    (next_lvl.required_exp - u.total_exp) AS exp_needed,
    -- 진행률 (%) 계산: (현재경험치 - 현재레벨시작경험치) / (다음레벨경험치 - 현재레벨시작경험치)
    ROUND(
        (u.total_exp - cur_lvl.required_exp) / 
        (next_lvl.required_exp - cur_lvl.required_exp) * 100
    , 1) AS progress_percent
FROM users u
JOIN level_rules cur_lvl ON cur_lvl.level = u.level          -- 현재 레벨 규칙
JOIN level_rules next_lvl ON next_lvl.level = u.level + 1    -- 다음 레벨 규칙
WHERE u.user_id = 1;
💡 요약
level_rules 테이블에 레벨별 필요 경험치(Cut-line)를 미리 정의해둡니다.

사용자에게 경험치를 줄 때마다 total_exp를 업데이트합니다.

업데이트된 total_exp가 다음 레벨의 required_exp를 넘겼는지 확인하여 레벨업을 처리합니다.



// 1. 이벤트 클래스 생성
public record QuestCompleteEvent(String userId, String questName, int rewardAmount) {}

// 2. ServiceImpl에서 이벤트 발행
@Service
public class QuestServiceImpl implements QuestService {
    private final ApplicationEventPublisher publisher;

    public void completeQuest(String userId, String questId) {
        // ... 퀘스트 완료 로직 수행 ...
        
        // 성공 시 이벤트 트리거!
        publisher.publishEvent(new QuestCompleteEvent(userId, "성경읽기", 50));
    }
}

// 3. 리스너에서 후속 작업 처리 (예: 토스트 알림 데이터 생성)
@Component
public class NotificationHandler {
    @EventListener
    public void handleQuestEvent(QuestCompleteEvent event) {
        System.out.println(event.userId() + "님에게 알림 전송: " + event.rewardAmount() + "달란트 획득!");
    }
}


스프링 프레임워크에서 ServiceImpl의 특정 로직이 성공했을 때 자동으로 후속 작업을 수행하게 하는 가장 세련된 방법은 스프링 이벤트(Spring ApplicationEvent) 시스템을 사용하는 것입니다. 이는 '트리거'처럼 작동하며, 비즈니스 로직과 부가 기능(알림, 로그 등)을 깔끔하게 분리해 줍니다.

1. 스프링 이벤트 구조 및 구현 방법
이 방식은 발행-구독(Publish-Subscribe) 모델을 따릅니다.

이벤트 클래스 (Event): 전달할 데이터를 담는 객체입니다.

발행 (Publisher): ApplicationEventPublisher를 통해 이벤트를 던집니다.

리스너 (Listener): @EventListener가 붙은 메서드가 이벤트를 낚아채서 실행합니다.


2. 트랜잭션 처리 가능 여부 (@TransactionalEventListener)
네, 트랜잭션과 완벽하게 연동됩니다. 단순히 @EventListener를 쓰면 원본 로직의 성공 여부와 상관없이 이벤트가 발생할 수 있지만, **@TransactionalEventListener**를 사용하면 트랜잭션 상태에 맞춰 정밀하게 제어할 수 있습니다.

phase = TransactionPhase.AFTER_COMMIT (기본값):

메인 비즈니스 로직(DB 저장 등)이 최종적으로 Commit 되었을 때만 후속 작업이 실행됩니다.

예: 퀘스트 저장이 성공했을 때만 "달란트 획득" 알림을 보냅니다.

phase = TransactionPhase.AFTER_ROLLBACK:

로직 수행 중 에러가 발생하여 Rollback 되었을 때만 실행됩니다.

예: 실패 로그를 남기거나 복구 로직을 실행할 때 유용합니다.
